<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="多线程相关多线程实现的几种方式？什么是线程安全？ (1).继承Thread类 (2).实现Runnable接口（Callable接口） 线程安全就是说多线程访问共享数据，不会产生不确定的结果  volatile的 原理，作用，能代替锁吗？ voliate 关键字是多线程读取变量时绕过cpu cache 直接读取主内存的内容，从而保证变量一致性 volatile主要作用是保证可见性以及有序性。 vo">
<meta property="og:type" content="article">
<meta property="og:title" content="逸清风扬的博客">
<meta property="og:url" content="http://yoursite.com/2018/12/10/多线程相关/index.html">
<meta property="og:site_name" content="逸清风扬的博客">
<meta property="og:description" content="多线程相关多线程实现的几种方式？什么是线程安全？ (1).继承Thread类 (2).实现Runnable接口（Callable接口） 线程安全就是说多线程访问共享数据，不会产生不确定的结果  volatile的 原理，作用，能代替锁吗？ voliate 关键字是多线程读取变量时绕过cpu cache 直接读取主内存的内容，从而保证变量一致性 volatile主要作用是保证可见性以及有序性。 vo">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://img-blog.csdn.net/20170924153653987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3NDgyNzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3130736-5c1afc9e826c77cd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/web">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3130736-b33dce23ceaf66ba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/web">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/8030332-a627c39a7f44f7e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/web">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/8030332-8796ca91810b2234.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/web">
<meta property="og:updated_time" content="2018-12-11T06:36:56.724Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="逸清风扬的博客">
<meta name="twitter:description" content="多线程相关多线程实现的几种方式？什么是线程安全？ (1).继承Thread类 (2).实现Runnable接口（Callable接口） 线程安全就是说多线程访问共享数据，不会产生不确定的结果  volatile的 原理，作用，能代替锁吗？ voliate 关键字是多线程读取变量时绕过cpu cache 直接读取主内存的内容，从而保证变量一致性 volatile主要作用是保证可见性以及有序性。 vo">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170924153653987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3NDgyNzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/10/多线程相关/">





  <title> | 逸清风扬的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">逸清风扬的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">留下探索的zu'ji</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/10/多线程相关/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="卢晓波">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="逸清风扬的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-10T10:50:24+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="多线程相关"><a href="#多线程相关" class="headerlink" title="多线程相关"></a>多线程相关</h3><h4 id="多线程实现的几种方式？什么是线程安全？"><a href="#多线程实现的几种方式？什么是线程安全？" class="headerlink" title="多线程实现的几种方式？什么是线程安全？"></a>多线程实现的几种方式？什么是线程安全？</h4><ul>
<li>(1).继承Thread类</li>
<li>(2).实现Runnable接口（Callable接口）</li>
<li>线程安全就是说多线程访问共享数据，不会产生不确定的结果</li>
</ul>
<h4 id="volatile的-原理，作用，能代替锁吗？"><a href="#volatile的-原理，作用，能代替锁吗？" class="headerlink" title="volatile的 原理，作用，能代替锁吗？"></a>volatile的 原理，作用，能代替锁吗？</h4><ul>
<li>voliate 关键字是多线程读取变量时绕过cpu cache 直接读取主内存的内容，从而保证变量一致性</li>
<li>volatile主要作用是保证可见性以及有序性。</li>
<li>volatile主要解决的是一个线程修改变量值之后，其他线程立马可以读到最新的值，是解决这个问题的，也就是可见性！</li>
<li>参考连接：<ul>
<li><a href="https://juejin.im/post/5c0528fcf265da610f637b7d" target="_blank" rel="noopener">https://juejin.im/post/5c0528fcf265da610f637b7d</a></li>
</ul>
</li>
</ul>
<h4 id="一个线程的生命周期状态图"><a href="#一个线程的生命周期状态图" class="headerlink" title="一个线程的生命周期状态图"></a>一个线程的生命周期状态图</h4><ul>
<li>1、新建：创建线程对象 </li>
<li>2、就绪：线程有执行资格，没有执行权 </li>
<li>3、运行：有执行资格，有执行权 </li>
<li>4、阻塞：由于一些操作让线程改变了状态，没有执行资格，没有执行权 </li>
<li>另一些操作可以把它给激活，激活处于就绪状态 </li>
<li>5、死亡：线程对象变成垃圾，等待被回收</li>
<li><img src="https://img-blog.csdn.net/20170924153653987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY3NDgyNzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="框架图"> </li>
</ul>
<h4 id="sleep和wait的区别，以及wait的实现原理"><a href="#sleep和wait的区别，以及wait的实现原理" class="headerlink" title="sleep和wait的区别，以及wait的实现原理"></a>sleep和wait的区别，以及wait的实现原理</h4><ul>
<li>这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。</li>
<li>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</li>
<li>锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<ul>
<li>sleep不出让系统资源；</li>
<li>wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。</li>
<li>sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。</li>
</ul>
</li>
<li>使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(x)&#123;</span><br><span class="line">      x.notify()</span><br><span class="line">     //或者wait()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="lock和Synchronized的区别"><a href="#lock和Synchronized的区别" class="headerlink" title="lock和Synchronized的区别"></a>lock和Synchronized的区别</h4><ul>
<li>主要相同点：Lock能完成synchronized所实现的所有功能</li>
<li>1.lock实现的锁是代码层面，Synchronized则是通过jvm层面实现锁的（中间可插入jvm式如何实现锁的如6问中的问题）</li>
<li>2.线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断</li>
<li>如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</li>
<li>3.ReentrantLock功能性方面更全面（性能更好），比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性</li>
<li>4.代码角度：ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错</li>
<li>5.死锁角度：ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁</li>
<li>6.在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态</li>
</ul>
<h4 id="Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）"><a href="#Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）" class="headerlink" title="Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）"></a>Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）</h4><ul>
<li>synchronized (this)原理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">"Method 1 start"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3130736-5c1afc9e826c77cd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/web" alt="框架图"> </p>
<ul>
<li>（1）monitorenter</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时</span><br><span class="line">尝试获取monitor的所有权，过程如下：</span><br><span class="line">1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</span><br><span class="line">2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。</span><br><span class="line">3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，</span><br><span class="line">再重新尝试获取monitor的所有权。</span><br></pre></td></tr></table></figure>
<ul>
<li>（2）monitorexit</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行monitorexit的线程必须是objectref所对应的monitor的所有者。</span><br><span class="line">指令执行时，monitor的进入数减1，如果减1后进入数为0，</span><br><span class="line">那线程退出monitor，不再是这个monitor的所有者。</span><br><span class="line">其他被这个monitor阻塞的线程可以尝试去获取这个</span><br><span class="line">monitor 的所有权。</span><br></pre></td></tr></table></figure>
<ul>
<li>同步方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3130736-b33dce23ceaf66ba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/web" alt="框架图"></p>
<ul>
<li>反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现）。</li>
<li>常量池中多了ACC_SYNCHRONIZED标示符。</li>
<li>当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。</li>
<li>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</li>
</ul>
<ul>
<li>参考链接：<ul>
<li><a href="https://www.jianshu.com/p/7b0d6264fe10" target="_blank" rel="noopener">https://www.jianshu.com/p/7b0d6264fe10</a></li>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/54883355</a></li>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/54883355</a>  （比较详细）</li>
</ul>
</li>
</ul>
<h4 id="锁优化的方式"><a href="#锁优化的方式" class="headerlink" title="锁优化的方式"></a>锁优化的方式</h4><ul>
<li>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</li>
<li><p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着__竞争的激烈而逐渐升级。<strong><em>注意锁可以升级不可降级</em></strong>，这种策略是为了提高获得锁和释放锁的效率</p>
</li>
<li><p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">https://blog.csdn.net/chenssy/article/details/54883355</a></li>
<li><a href="https://blog.csdn.net/u012465296/article/details/53022317" target="_blank" rel="noopener">https://blog.csdn.net/u012465296/article/details/53022317</a></li>
</ul>
</li>
</ul>
<h4 id="解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景"><a href="#解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景" class="headerlink" title="解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景"></a>解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景</h4><ul>
<li><p>1、自旋锁</p>
<ul>
<li>自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。</li>
<li>使用自旋锁后，线程被挂起的几率相对减少，线程执行的连贯性相对加强。因此，对于那些锁竞争不是很激烈，锁占用时间很短的并发线程，具有一定的积极意义，但对于锁竞争激烈，单线程锁占用很长时间的并发程序，自旋锁在自旋等待后，往往毅然无法获得对应的锁，不仅仅白白浪费了CPU时间，最终还是免不了被挂起的操作 ，反而浪费了系统的资源。</li>
<li>在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。</li>
<li>在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。</li>
</ul>
</li>
<li><p>可能引起的问题：</p>
<ul>
<li>1.过多占据CPU时间：如果锁的当前持有者长时间不释放该锁，那么等待者将长时间的占据cpu时间片，导致CPU资源的浪费，因此可以设定一个时间，当锁持有者超过这个时间不释放锁时，等待者会放弃CPU时间片阻塞；</li>
<li>2.死锁问题：试想一下，有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。因此递归程序使用自旋锁应该遵循以下原则：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。</li>
</ul>
</li>
<li><p>2、阻塞锁</p>
<ul>
<li>让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态。。</li>
<li>JAVA中，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字（其中的重量锁），ReentrantLock，Object.wait()\notify()</li>
</ul>
</li>
<li><p>3、可重入锁</p>
<ul>
<li>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</li>
<li>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁</li>
</ul>
</li>
<li><p>4 悲观锁和乐观锁</p>
<ul>
<li><p>悲观锁(Pessimistic Lock), 顾名思义就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。独占锁是悲观锁的一种实现</p>
</li>
<li><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。使用CAS来保证,保证这个操作的原子性</p>
</li>
<li><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>5 轮询锁和定时锁<ul>
<li>由tryLock实现，与无条件获取锁模式相比，它们具有更完善的错误恢复机制。可避免死锁的发生：</li>
<li>boolean tryLock()：仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException：</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果锁可用，则此方法将立即返回值 true。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在发生以下三种情况之一前，该线程将一直处于休眠状态：</span><br><span class="line">锁由当前线程获得；或者</span><br><span class="line">其他某个线程中断当前线程，并且支持对锁获取的中断；或者</span><br><span class="line">已超过指定的等待时间</span><br><span class="line">如果获得了锁，则返回值 true。</span><br><span class="line">如果当前线程：</span><br><span class="line">在进入此方法时已经设置了该线程的中断状态；或者</span><br><span class="line">在获取锁时被中断，并且支持对锁获取的中断，</span><br><span class="line">则将抛出 InterruptedException，并会清除当前线程的已中断状态。</span><br><span class="line">如果超过了指定的等待时间，则将返回值 false。如果 time 小于等于 0，该方法将完全不等待。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>6 显示锁和内置锁</p>
<ul>
<li>显示锁用Lock来定义、内置锁用syschronized。</li>
<li>内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</li>
<li>内置锁是互斥锁。</li>
</ul>
</li>
<li><p>7 读-写锁</p>
<ul>
<li>Lock接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。</li>
<li>Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock，也有具体的实现ReentrantReadWriteLock，详细的API可以查看JavaAPI文档。</li>
<li>ReentrantReadWriteLock 和 ReentrantLock 不是继承关系，但都是基于 AbstractQueuedSynchronizer 来实现。</li>
<li>lock方法 是基于CAS 来实现的</li>
<li><p>ReadWriteLock中暴露了两个Lock对象：</p>
</li>
<li><p>在读写锁的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。读写锁是一种性能优化的策略。</p>
</li>
<li><p>RentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）还是公平的锁。</p>
</li>
</ul>
</li>
<li><p>8 对象锁和类锁</p>
<ul>
<li>java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。</li>
<li>类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的.</li>
<li><p>synchronized只是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，并不能阻止其他线程访问不需要获得该内置锁的方法。</p>
</li>
<li><p>调用对象wait()方法时，会释放持有的对象锁，以便于调用notify方法使用。notify()调用之后，会等到notify所在的线程执行完之后再释放锁</p>
</li>
</ul>
</li>
<li><p>9：锁粗化（Lock Coarsening）：</p>
<ul>
<li>锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferTest</span> </span>&#123;</span><br><span class="line">     StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">()</span></span>&#123;</span><br><span class="line">         stringBuffer.append(<span class="string">"a"</span>);</span><br><span class="line">         stringBuffer.append(<span class="string">"b"</span>);</span><br><span class="line">         stringBuffer.append(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每次调用stringBuffer.append方法都需要加锁和解锁，</span><br><span class="line">如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，</span><br><span class="line">就会将其合并成一次范围更大的加锁和解锁操作，</span><br><span class="line">即在第一次append方法时进行加锁，</span><br><span class="line">最后一次append方法结束后进行解锁。</span><br></pre></td></tr></table></figure>
<ul>
<li>10 互斥锁<ul>
<li>互斥锁, 指的是一次最多只能有一个线程持有的锁。如Java的Lock</li>
</ul>
</li>
<li>11 锁消除（Lock Elimination）：<ul>
<li>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest02</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         SynchronizedTest02 test02 = <span class="keyword">new</span> SynchronizedTest02();</span><br><span class="line">          <span class="comment">//启动预热</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">             test02.append(<span class="string">"abc"</span>, <span class="string">"def"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"Time="</span> + (System.currentTimeMillis() - start));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的append是一个同步方法，</span><br><span class="line">但是这段程序中的StringBuffer属于一个局部变量，</span><br><span class="line">并且不会从该方法中逃逸出去，所以其实这过程是线程安全的，</span><br><span class="line">可以将锁消除</span><br></pre></td></tr></table></figure>
<ul>
<li><p>13.锁膨胀</p>
<ul>
<li><p>无锁状态-》偏向锁-》轻量级锁-》重量级锁</p>
</li>
<li><p>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。JDK 1.6中默认是开启偏向锁和轻量级锁的，</p>
</li>
<li>锁膨胀：从轻量锁膨胀到重量级锁是在轻量级锁解锁过程发生的。</li>
<li>重量级锁：Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。</li>
<li>轻量级锁：“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。</li>
<li>偏向锁：　引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的CAS原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。</li>
<li>无锁状态：在代码进入同步块的时候，如果同步对象锁状态为无锁状态。</li>
<li>重量级锁、轻量级锁和偏向锁之间转换：</li>
</ul>
</li>
</ul>
<h4 id="用过哪些原子类，他们的原理是什么？"><a href="#用过哪些原子类，他们的原理是什么？" class="headerlink" title="用过哪些原子类，他们的原理是什么？"></a>用过哪些原子类，他们的原理是什么？</h4><ul>
<li>AtomicInteger：操作int类型</li>
<li>AtomicLong：操作long类型</li>
<li><p>AtomicBoolean：操作boolean类型</p>
</li>
<li><p>AtomicInteger</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这其中有个很重要的东西就是unsafe，这个是sun.misc.Unsafe类型的实例，</span><br><span class="line">现在一定注意，这个Unsafe类在JUC包中被频繁使用到的，所以特别重要。</span><br></pre></td></tr></table></figure>
<h4 id="JUC下研究过哪些并发工具，讲讲原理"><a href="#JUC下研究过哪些并发工具，讲讲原理" class="headerlink" title="JUC下研究过哪些并发工具，讲讲原理"></a>JUC下研究过哪些并发工具，讲讲原理</h4><ul>
<li>参考链接：<ul>
<li><a href="http://www.iocoder.cn/JUC/good-collection/" target="_blank" rel="noopener">http://www.iocoder.cn/JUC/good-collection/</a> （总目录）</li>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/" target="_blank" rel="noopener">http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/" target="_blank" rel="noopener">http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/</a></li>
</ul>
</li>
</ul>
<h4 id="用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize-maxSize等"><a href="#用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize-maxSize等" class="headerlink" title="用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize,maxSize等"></a>用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize,maxSize等</h4><ul>
<li>线程池优点：<ul>
<li>1.降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>2.提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>3.提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
</li>
<li>通过ThreadPoolExecutor来创建一个线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                       BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建</li>
<li>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
<li>unit - keepAliveTime 参数的时间单位。 </li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列：<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序</li>
<li>LinkedBlockingQueue一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列</li>
</ul>
</li>
</ul>
<ul>
<li>threadFactory - 执行程序创建新线程时使用的工厂</li>
<li>RejectedExecutionHandler（饱和策略）<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务</li>
</ul>
</li>
</ul>
<ul>
<li>新任务进入时线程池的执行策略：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">于corePoolSize，则任务根本不会存入queue中，而是直接运行） </span><br><span class="line">如果运行的线程大于等于 corePoolSize，</span><br><span class="line">则 Executor始终首选将请求加入队列，而不添加新的线程。 </span><br><span class="line">如果无法将请求加入队列，则创建新的线程，</span><br><span class="line">除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝</span><br></pre></td></tr></table></figure>
<ul>
<li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Executors.newFixedThreadPool(int)（固定大小线程池）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Executors.newSingleThreadExecutor()（单个后台线程）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h4 id="线程池关闭的方法有几种？各自的区别是什么？"><a href="#线程池关闭的方法有几种？各自的区别是什么？" class="headerlink" title="线程池关闭的方法有几种？各自的区别是什么？"></a>线程池关闭的方法有几种？各自的区别是什么？</h4><ul>
<li>通过调用线程池的shutdown或shutdownNow方法来关闭线程池</li>
<li>原理:  <ul>
<li>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</li>
</ul>
</li>
<li>区别：<ul>
<li>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表</li>
<li>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程</li>
<li>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</li>
<li>通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</li>
</ul>
</li>
</ul>
<h4 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h4><ul>
<li>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</li>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不+ getActiveCount：获取活动的线程数。</li>
<li>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？"><a href="#假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？" class="headerlink" title="假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？"></a>假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor 设置定时，进行调度。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</span><br><span class="line"><span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1、调用的Thread的包装，由在ThreadPoolExecutor中的Worker调用你传入的Runnable的run方法，变成了Worker调用Runnable的run方法，由它来处理时间片的信息调用你传入的线程。</li>
<li>2、ScheduledFutureTask类在整个过程中提供了基础参考的方法，其中最为关键的就是实现了接口Comparable，实现内部的compareTo方法，也实现了Delayed接口中的getDelay方法用以判定时间（当然Delayed接口本身也是继承于Comparable，我们不要纠结于细节概念就好）。</li>
<li>3、等待队列由在ThreadPoolExecutor中默认使用的LinkedBlockingQueue换成了DelayQueue（它是被DelayWorkQueue包装了一下子，没多大区别），而DelayQueue主要提供了一个信号量“available”来作为写入和读取的信号控制开关，通过另一个优先级队列“PriorityQueue”来控制实际的队列顺序，他们的顺序就是基于上面提到的ScheduledFutureTask类中的compareTo方法，而是否运行也是基于getDelay方法来实现的。</li>
<li>4、ScheduledFutureTask类的run方法会判定是否为时间片信息，如果为时间片，在执行完对应的方法后，开始计算下一次执行时间（注意判定时间片大于0，小于0，分别代表的是以当前执行完的时间为准计算下一次时间还是以当前时间为准），这个在前面有提到。</li>
<li>5、它是支持多线程的，和Timer的机制最大的区别就在于多个线程会最征用这个队列，队里的排序方式和Timer有很多相似之处，并非完全有序，而是通过位移动来尽量找到合适的位置，有点类似贪心的算法，呵呵。</li>
</ul>
<h4 id="spring-的controller是单例还是多例，怎样保证并发的安全？"><a href="#spring-的controller是单例还是多例，怎样保证并发的安全？" class="headerlink" title="spring 的controller是单例还是多例，怎样保证并发的安全？"></a>spring 的controller是单例还是多例，怎样保证并发的安全？</h4><ul>
<li>单例</li>
<li>通过单例工厂 DefaultSingletonBeanRegistry实现单例</li>
<li><p>通过保AsyncTaskExecutor持安全</p>
</li>
<li><p>1.用ThreadLoacal保证</p>
</li>
<li><p>2.bean配置中用scope=prototype</p>
</li>
<li><p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/eba1fef77442" target="_blank" rel="noopener">https://www.jianshu.com/p/eba1fef77442</a></li>
</ul>
</li>
</ul>
<h4 id="用三个线程按顺序循环打印abc三个字母，比如abcabcab"><a href="#用三个线程按顺序循环打印abc三个字母，比如abcabcab" class="headerlink" title="用三个线程按顺序循环打印abc三个字母，比如abcabcab"></a>用三个线程按顺序循环打印abc三个字母，比如abcabcab</h4><ul>
<li>参考链接：<ul>
<li><a href="https://blog.csdn.net/xiaokang123456kao/article/details/77331878" target="_blank" rel="noopener">https://blog.csdn.net/xiaokang123456kao/article/details/77331878</a></li>
</ul>
</li>
</ul>
<h4 id="ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？"><a href="#ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？" class="headerlink" title="ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？"></a>ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？</h4><ul>
<li><ol>
<li>ThreadLocalMap变量属于线程（Thread）的内部属性,不同的线程（Thread）拥有完全不同的ThreadLocalMap变量.</li>
</ol>
</li>
<li><ol start="2">
<li>线程（Thread）中的ThreadLocalMap变量的值是在ThreadLocal对象进行set或者get操作时创建的.</li>
</ol>
</li>
<li><ol start="3">
<li>在创建ThreadLocalMap之前,会首先检查当前线程（Thread）中的ThreadLocalMap变量是否已经存在,如果不存在则创建一个；如果已经存在,则使用当前线程（Thread）已创建的ThreadLocalMap.</li>
</ol>
</li>
<li><ol start="4">
<li>使用当前线程（Thread）的ThreadLocalMap的关键在于使用当前的ThreadLocal的实例作为key进行存储ThreadLocal模式,至少从两个方面完成了数据访问隔离,有了横向和纵向的两种不同的隔离方式,ThreadLocal模式就能真正地做到线程安全：<ul>
<li>纵向隔离 —— 线程（Thread）与线程（Thread）之间的数据访问隔离.这一点由线程（Thread）的数据结构保证.因为每个线程（Thread）在进行对象访问时,访问的都是各自线程自己的ThreadLocalMap</li>
<li>横向隔离 —— 同一个线程中,不同的ThreadLocal实例操作的对象之间的相互隔离.这一点由ThreadLocalMap在存储时,采用当前ThreadLocal的实例作为key来保证.</li>
</ul>
</li>
</ol>
</li>
<li>结论 ：使用ThreadLocal模式,可以使得数据在不同的编程层次得到有效地共享</li>
</ul>
<h4 id="如果让你实现一个并发安全的链表，你会怎么做"><a href="#如果让你实现一个并发安全的链表，你会怎么做" class="headerlink" title="如果让你实现一个并发安全的链表，你会怎么做"></a>如果让你实现一个并发安全的链表，你会怎么做</h4><ul>
<li>参考链接<ul>
<li><a href="https://blog.csdn.net/iter_zc/article/details/41115021" target="_blank" rel="noopener">实现一个基于链表的无锁Set集合</a></li>
<li><a href="http://blog.csdn.net/xingjiarong/article/details/48046751" target="_blank" rel="noopener">http://blog.csdn.net/xingjiarong/article/details/48046751</a></li>
</ul>
</li>
</ul>
<h4 id="有哪些无锁的数据结构，他们的实现原理是什么？"><a href="#有哪些无锁的数据结构，他们的实现原理是什么？" class="headerlink" title="有哪些无锁的数据结构，他们的实现原理是什么？"></a>有哪些无锁的数据结构，他们的实现原理是什么？</h4><ul>
<li>使用CAS的一些类，AtomicXXX类，非阻塞队列ConcurrentLinkedQueue，跳表ConcurrentSkipList。</li>
<li>CAS漏洞：CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</li>
<li><p>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。<br>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<ul>
<li>关于ABA问题参考文档: <ul>
<li><a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html" target="_blank" rel="noopener">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></li>
</ul>
</li>
</ul>
</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
<h4 id="讲讲java同步机制的wait和notify"><a href="#讲讲java同步机制的wait和notify" class="headerlink" title="讲讲java同步机制的wait和notify"></a>讲讲java同步机制的wait和notify</h4><ul>
<li>wait()和notify()一系列的方法，是属于对象的，不是属于线程的。它们用在线程同步时，synchronized语句块中。</li>
<li>wait()意思是说，我等会儿再用这把锁，CPU也让给你们，我先休息一会儿！</li>
<li>notify()意思是说，我用完了，你们谁用？</li>
<li>wait()会让出对象锁，同时，当前线程休眠，等待被唤醒，如果不被唤醒，就一直等在那儿。</li>
<li>notify()并不会让当前线程休眠，但会唤醒休眠的线程。</li>
<li>参考链接：<ul>
<li><a href="https://blog.csdn.net/superit401/article/details/52254087" target="_blank" rel="noopener">https://blog.csdn.net/superit401/article/details/52254087</a></li>
</ul>
</li>
</ul>
<h4 id="多线程如果线程挂住了怎么办？"><a href="#多线程如果线程挂住了怎么办？" class="headerlink" title="多线程如果线程挂住了怎么办？"></a>多线程如果线程挂住了怎么办？</h4><ul>
<li>jstack 打印线程栈信息,分析线程运行情况，排查原因，定位代码，修复后重启</li>
</ul>
<h4 id="countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）"><a href="#countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）" class="headerlink" title="countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）"></a>countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）</h4><ul>
<li>1、CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。</li>
<li>2、cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！</li>
<li>3、CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>4,、CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。</li>
<li>参考链接：<ul>
<li><a href="https://blog.csdn.net/a347911/article/details/53465445" target="_blank" rel="noopener">https://blog.csdn.net/a347911/article/details/53465445</a></li>
</ul>
</li>
</ul>
<h4 id="对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？"><a href="#对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？" class="headerlink" title="对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？"></a>对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？</h4><ul>
<li>参考链接：<a href="https://juejin.im/post/5c07e59cf265da617464a09c" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之谈谈你对AQS的理解</a></li>
<li><a href="http://blog.tops001.xin/2016/08/28/java-lock/#more" target="_blank" rel="noopener">http://blog.tops001.xin/2016/08/28/java-lock/#more</a></li>
<li><a href="http://blog.csdn.net/yanyan19880509/article/details/52435135" target="_blank" rel="noopener">http://blog.csdn.net/yanyan19880509/article/details/52435135</a></li>
</ul>
<h4 id="使用Synchronized修饰静态方法和非静态方法有什么区别"><a href="#使用Synchronized修饰静态方法和非静态方法有什么区别" class="headerlink" title="使用Synchronized修饰静态方法和非静态方法有什么区别"></a>使用Synchronized修饰静态方法和非静态方法有什么区别</h4><ul>
<li>静态方法是类锁，非静态方法是对象锁<ul>
<li><ol>
<li>所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，  </li>
</ol>
</li>
<li><ol start="2">
<li>该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，  </li>
</ol>
</li>
<li><ol start="3">
<li>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，  </li>
</ol>
</li>
<li><ol start="4">
<li>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li>
</ol>
</li>
<li><ol start="5">
<li>而所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，  </li>
</ol>
</li>
<li><ol start="6">
<li>所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，  </li>
</ol>
</li>
<li><ol start="7">
<li>其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，  </li>
</ol>
</li>
<li><ol start="8">
<li>还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！ </li>
</ol>
</li>
</ul>
</li>
<li>参考链接：<ul>
<li><a href="https://blog.csdn.net/u010842515/article/details/65443084" target="_blank" rel="noopener">https://blog.csdn.net/u010842515/article/details/65443084</a></li>
</ul>
</li>
</ul>
<h4 id="简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处"><a href="#简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处" class="headerlink" title="简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处"></a>简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处</h4><ul>
<li>Java提供的线程安全的Queue可以分为阻塞队列和非阻塞队列，<ul>
<li>其中阻塞队列的典型例子是BlockingQueue，</li>
<li>非阻塞队列的典型例子是ConcurrentLinkedQueue，</li>
<li>在实际应用中要根据实际需要选用阻塞队列或者非阻塞队列</li>
</ul>
</li>
<li>LinkedBlockingQueue<ul>
<li>由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。</li>
</ul>
</li>
</ul>
<ul>
<li><p>ConcurrentLinkedQueue</p>
<ul>
<li>ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。对比锁机制的实现，使用无锁机制的难点在于要充分考虑线程间的协调。简单的说就是多个线程对内部数据结构进行访问时，如果其中一个线程执行的中途因为一些原因出现故障，其他的线程能够检测并帮助完成剩下的操作。这就需要把对数据结构的操作过程精细的划分成多个状态或阶段，考虑每个阶段或状态多线程访问会出现的情况。 </li>
<li><p>ConcurrentLinkedQueue有两个volatile的线程共享变量：head，tail。要保证这个队列的线程安全就是保证对这两个Node的引用的访问（更新，查看）的原子性和可见性，由于volatile本身能够保证可见性，所以就是对其修改的原子性要被保证。</p>
</li>
<li><p>另外还说一下，ConcurrentLinkedQueue的size()是要遍历一遍集合的，所以尽量要避免用size而改用isEmpty()，以免性能过慢。</p>
</li>
</ul>
</li>
</ul>
<h4 id="导致线程死锁的原因？怎么解除线程死锁？"><a href="#导致线程死锁的原因？怎么解除线程死锁？" class="headerlink" title="导致线程死锁的原因？怎么解除线程死锁？"></a>导致线程死锁的原因？怎么解除线程死锁？</h4><ul>
<li>产生死锁的四个必要条件：<ul>
<li>（1） 互斥条件：一个资源每次只能被一个进程使用。</li>
<li>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
</ul>
<h4 id="用过读写锁吗，原理是什么？一般什么场景下用？"><a href="#用过读写锁吗，原理是什么？一般什么场景下用？" class="headerlink" title="用过读写锁吗，原理是什么？一般什么场景下用？"></a>用过读写锁吗，原理是什么？一般什么场景下用？</h4><ul>
<li>一份数据，读取数据的操作次数通常高于写入数据的操作，而线程与线程间的读读操作是不涉及到线程安全的问题，没有必要加入互斥锁，只要在读-写，写-写期间上锁就行了</li>
<li>读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，我们只要上好相应的锁即可</li>
<li><p>线程进入读锁的前提条件：</p>
<ul>
<li><ol>
<li>没有其他线程的写锁</li>
</ol>
</li>
<li><ol start="2">
<li>没有写请求，或者有写请求但调用线程和持有锁的线程是同一个线程</li>
</ol>
</li>
</ul>
</li>
<li><p>进入写锁的前提条件：</p>
<ul>
<li><ol>
<li>没有其他线程的读锁</li>
</ol>
</li>
<li><ol start="2">
<li>没有其他线程的写锁</li>
</ol>
</li>
</ul>
</li>
<li><p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/training2007/article/details/78837096" target="_blank" rel="noopener">https://blog.csdn.net/training2007/article/details/78837096</a></li>
<li><a href="https://blog.csdn.net/cdw8131197/article/details/52601559" target="_blank" rel="noopener">https://blog.csdn.net/cdw8131197/article/details/52601559</a></li>
</ul>
</li>
</ul>
<h4 id="延迟队列的实现方式，delayQueue和时间轮算法的异同？"><a href="#延迟队列的实现方式，delayQueue和时间轮算法的异同？" class="headerlink" title="延迟队列的实现方式，delayQueue和时间轮算法的异同？"></a>延迟队列的实现方式，delayQueue和时间轮算法的异同？</h4><h4 id="concurrenthashmap具体实现及其原理，jdk8下的改版"><a href="#concurrenthashmap具体实现及其原理，jdk8下的改版" class="headerlink" title="concurrenthashmap具体实现及其原理，jdk8下的改版"></a>concurrenthashmap具体实现及其原理，jdk8下的改版</h4><h4 id="cas是什么，他会产生什么问题"><a href="#cas是什么，他会产生什么问题" class="headerlink" title="cas是什么，他会产生什么问题"></a>cas是什么，他会产生什么问题</h4><ul>
<li>ABA问题的解决，如加入修改次数、版本号</li>
</ul>
<h4 id="简述AQS的实现原理"><a href="#简述AQS的实现原理" class="headerlink" title="简述AQS的实现原理"></a>简述AQS的实现原理</h4><ul>
<li>参考链接：<ul>
<li><a href="https://juejin.im/post/5c07e59cf265da617464a09c" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之谈谈你对AQS的理解</a></li>
</ul>
</li>
</ul>
<h4 id="concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用"><a href="#concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用" class="headerlink" title="concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用"></a>concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用</h4><ul>
<li>参考concurrentHashMap</li>
</ul>
<h4 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a>LockSupport工具</h4><ul>
<li>参考链接：<ul>
<li><a href="https://www.jianshu.com/p/9677a754cf60" target="_blank" rel="noopener">https://www.jianshu.com/p/9677a754cf60</a></li>
</ul>
</li>
</ul>
<h4 id="Condition接口及其实现原理"><a href="#Condition接口及其实现原理" class="headerlink" title="Condition接口及其实现原理"></a>Condition接口及其实现原理</h4><ul>
<li>参考链接：<ul>
<li><a href="https://blog.csdn.net/fuyuwei2015/article/details/72602182" target="_blank" rel="noopener">https://blog.csdn.net/fuyuwei2015/article/details/72602182</a></li>
</ul>
</li>
</ul>
<h4 id="Fork-Join框架的理解"><a href="#Fork-Join框架的理解" class="headerlink" title="Fork/Join框架的理解"></a>Fork/Join框架的理解</h4><ul>
<li>Fork/Join框架是Java7提供的并行执行任务框架，思想是将大任务分解成小任务，然后小任务又可以继续分解，然后每个小任务分别计算出结果再合并起来，最后将汇总的结果作为大任务结果<br><img src="http://upload-images.jianshu.io/upload_images/8030332-a627c39a7f44f7e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/627/format/web" alt="图片"><br><img src="http://upload-images.jianshu.io/upload_images/8030332-8796ca91810b2234.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/web" alt="图"></li>
<li>参考链接：<ul>
<li><a href="https://www.jianshu.com/p/6b9347a22fd1" target="_blank" rel="noopener">Fork/Join框架解析</a></li>
</ul>
</li>
</ul>
<h4 id="jdk8的parallelStream的理解"><a href="#jdk8的parallelStream的理解" class="headerlink" title="jdk8的parallelStream的理解"></a>jdk8的parallelStream的理解</h4><ul>
<li>参考链接：</li>
<li><a href="https://www.jianshu.com/p/bd825cb89e00" target="_blank" rel="noopener">深入浅出parallelStream</a></li>
</ul>
<h4 id="分段锁的原理-锁颗粒度减小的思考（参考concurrentHashMap）"><a href="#分段锁的原理-锁颗粒度减小的思考（参考concurrentHashMap）" class="headerlink" title="分段锁的原理,锁颗粒度减小的思考（参考concurrentHashMap）"></a>分段锁的原理,锁颗粒度减小的思考（参考concurrentHashMap）</h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/04/netty源码/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">卢晓波</p>
              <p class="site-description motion-element" itemprop="description">世界很大，我想去看看</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程相关"><span class="nav-number">1.</span> <span class="nav-text">多线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程实现的几种方式？什么是线程安全？"><span class="nav-number">1.1.</span> <span class="nav-text">多线程实现的几种方式？什么是线程安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile的-原理，作用，能代替锁吗？"><span class="nav-number">1.2.</span> <span class="nav-text">volatile的 原理，作用，能代替锁吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个线程的生命周期状态图"><span class="nav-number">1.3.</span> <span class="nav-text">一个线程的生命周期状态图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep和wait的区别，以及wait的实现原理"><span class="nav-number">1.4.</span> <span class="nav-text">sleep和wait的区别，以及wait的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock和Synchronized的区别"><span class="nav-number">1.5.</span> <span class="nav-text">lock和Synchronized的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）"><span class="nav-number">1.6.</span> <span class="nav-text">Synchronized的原理是什么？一般用在什么地方（比如加载静态方法和非静态方法的区别，静态方法和和非静态方法同时执行会有什么影响）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁优化的方式"><span class="nav-number">1.7.</span> <span class="nav-text">锁优化的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景"><span class="nav-number">1.8.</span> <span class="nav-text">解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁，以及一些他们的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用过哪些原子类，他们的原理是什么？"><span class="nav-number">1.9.</span> <span class="nav-text">用过哪些原子类，他们的原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JUC下研究过哪些并发工具，讲讲原理"><span class="nav-number">1.10.</span> <span class="nav-text">JUC下研究过哪些并发工具，讲讲原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize-maxSize等"><span class="nav-number">1.11.</span> <span class="nav-text">用过线程池吗？请说明原理，讲讲说出newCache和newFixed有什么区别，构造函数的各个参数的含义是什么？比如coreSize,maxSize等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池关闭的方法有几种？各自的区别是什么？"><span class="nav-number">1.12.</span> <span class="nav-text">线程池关闭的方法有几种？各自的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池的监控"><span class="nav-number">1.13.</span> <span class="nav-text">线程池的监控</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？"><span class="nav-number">2.</span> <span class="nav-text">假如有一个第三方接口，有很多线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用他，如何做到？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-的controller是单例还是多例，怎样保证并发的安全？"><span class="nav-number">2.1.</span> <span class="nav-text">spring 的controller是单例还是多例，怎样保证并发的安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用三个线程按顺序循环打印abc三个字母，比如abcabcab"><span class="nav-number">2.2.</span> <span class="nav-text">用三个线程按顺序循环打印abc三个字母，比如abcabcab</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？"><span class="nav-number">2.3.</span> <span class="nav-text">ThreadLocal用过吗，用途是什么？原理是什么？用的时候要注意什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如果让你实现一个并发安全的链表，你会怎么做"><span class="nav-number">2.4.</span> <span class="nav-text">如果让你实现一个并发安全的链表，你会怎么做</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有哪些无锁的数据结构，他们的实现原理是什么？"><span class="nav-number">2.5.</span> <span class="nav-text">有哪些无锁的数据结构，他们的实现原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#讲讲java同步机制的wait和notify"><span class="nav-number">2.6.</span> <span class="nav-text">讲讲java同步机制的wait和notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程如果线程挂住了怎么办？"><span class="nav-number">2.7.</span> <span class="nav-text">多线程如果线程挂住了怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）"><span class="nav-number">2.8.</span> <span class="nav-text">countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别（比如countdowlatch的await用法是怎么实现的？）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？"><span class="nav-number">2.9.</span> <span class="nav-text">对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Synchronized修饰静态方法和非静态方法有什么区别"><span class="nav-number">2.10.</span> <span class="nav-text">使用Synchronized修饰静态方法和非静态方法有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处"><span class="nav-number">2.11.</span> <span class="nav-text">简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导致线程死锁的原因？怎么解除线程死锁？"><span class="nav-number">2.12.</span> <span class="nav-text">导致线程死锁的原因？怎么解除线程死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用过读写锁吗，原理是什么？一般什么场景下用？"><span class="nav-number">2.13.</span> <span class="nav-text">用过读写锁吗，原理是什么？一般什么场景下用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟队列的实现方式，delayQueue和时间轮算法的异同？"><span class="nav-number">2.14.</span> <span class="nav-text">延迟队列的实现方式，delayQueue和时间轮算法的异同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrenthashmap具体实现及其原理，jdk8下的改版"><span class="nav-number">2.15.</span> <span class="nav-text">concurrenthashmap具体实现及其原理，jdk8下的改版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cas是什么，他会产生什么问题"><span class="nav-number">2.16.</span> <span class="nav-text">cas是什么，他会产生什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简述AQS的实现原理"><span class="nav-number">2.17.</span> <span class="nav-text">简述AQS的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用"><span class="nav-number">2.18.</span> <span class="nav-text">concurrent包中使用过哪些类？分别说说使用在什么场景？为什么要使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LockSupport工具"><span class="nav-number">2.19.</span> <span class="nav-text">LockSupport工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition接口及其实现原理"><span class="nav-number">2.20.</span> <span class="nav-text">Condition接口及其实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fork-Join框架的理解"><span class="nav-number">2.21.</span> <span class="nav-text">Fork/Join框架的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk8的parallelStream的理解"><span class="nav-number">2.22.</span> <span class="nav-text">jdk8的parallelStream的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分段锁的原理-锁颗粒度减小的思考（参考concurrentHashMap）"><span class="nav-number">2.23.</span> <span class="nav-text">分段锁的原理,锁颗粒度减小的思考（参考concurrentHashMap）</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">卢晓波</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
